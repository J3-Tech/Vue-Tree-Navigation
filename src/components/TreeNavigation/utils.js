import NavigationList from '../NavigationList/NavigationList.vue';

import pathTypes from '../../pathTypes';
const { PATH_TYPE_NONE, PATH_TYPE_ELEMENT, PATH_TYPE_ROUTE } = pathTypes;

/**
 * Get navigation item - a hyperlink, a router link, or a simple value.
 * Return only item name in case it is neither the route nor the element.
 * Return a router link in case the item is route.
 * Return a hyperlink in case the item is element.
 */
function getNavItem(createElement, item) {

  if (item.route === undefined && item.element === undefined) {
    return item.name;
  }

  let elementName;
  let attrs;
  let props;
  let classes;

  if (item.meta.pathType === PATH_TYPE_ELEMENT) {
    elementName = 'a';
    attrs = {
      href: item.meta.path,
    };
    props = {};
    classes = [];
  }

  if (item.meta.pathType === PATH_TYPE_ROUTE) {
    elementName = 'router-link';
    attrs = {};
    props = {
      to: item.meta.path,
    };
    classes = ['router-link']; // it is useful to be able to recognize if the <a> element was
                               // generated by the vue-router or if it is just a simple <a>
                               // (so we can style router links in a different way)
  }

  return createElement(elementName, {
    attrs,
    props,
    'class': classes,
  }, [
    item.name,
  ]);
}

/**
 * Check if there is an element appended to the end
 * of the path and then remove it.
 */
function removeElementFromPath(path) {
  const hashPos = path.indexOf('#');

  if (hashPos === -1) {
    return path;
  }

  return path.slice(0, hashPos);
}

/**
 * Return item metadata object: { path: ..., pathType: ... }
 */
function getItemMetadata(item, parent) {

  // item is its own parent
  if (parent === undefined) {
    if (item.element === undefined && item.route === undefined) {
      return {
        path: undefined,
        pathType: PATH_TYPE_NONE,
      };
    }

    if (item.route !== undefined) {
      return {
        path: '/' + item.route,  // TODO: clever join
        pathType: PATH_TYPE_ROUTE,
      };
    }

    if (item.element !== undefined) {
      return {
        path: item.element,
        pathType: PATH_TYPE_ELEMENT,
      };
    }
  }

  // route -> route
  if (parent.meta.pathType === PATH_TYPE_ROUTE && item.route !== undefined) {
    const parentPath = removeElementFromPath(parent.meta.path);

    return {
      path: parentPath + '/' + item.route, // TODO: clever join
      pathType: PATH_TYPE_ROUTE,
    };
  }

  // route -> element
  if (parent.meta.pathType === PATH_TYPE_ROUTE && item.element !== undefined) {
    const parentPath = removeElementFromPath(parent.meta.path);

    return {
      path: parentPath + item.element, // TODO: clever join
      pathType: PATH_TYPE_ROUTE,
    };
  }

  // route -> label
  if (parent.meta.pathType === PATH_TYPE_ROUTE && item.element === undefined && item.route === undefined) {
    const parentPath = removeElementFromPath(parent.meta.path);

    return {
      path: parentPath,
      pathType: PATH_TYPE_ROUTE,
    };
  }

  // element -> route
  if (parent.meta.pathType === PATH_TYPE_ELEMENT && item.route !== undefined) {
    return {
      path: '/' + item.route,  // TODO: clever join
      pathType: PATH_TYPE_ROUTE,
    };
  }

  // element -> element
  if (parent.meta.pathType === PATH_TYPE_ELEMENT && item.element !== undefined) {
    return {
      path: item.element,
      pathType: PATH_TYPE_ELEMENT,
    };
  }

  // element -> label
  if (parent.meta.pathType === PATH_TYPE_ELEMENT && item.element === undefined && item.route === undefined) {
    return {
      path: undefined,
      pathType: PATH_TYPE_NONE,
    };
  }

  // label -> route
  if (parent.meta.pathType === PATH_TYPE_NONE && item.route !== undefined) {
    return {
      path: '/' + item.route, // TODO: clever join
      pathType: PATH_TYPE_ROUTE,
    };
  }

  // label -> element
  if (parent.meta.pathType === PATH_TYPE_NONE && item.element !== undefined) {
    return {
      path: item.element,
      pathType: PATH_TYPE_ELEMENT,
    };
  }

  // label -> label
  if (parent.meta.pathType === PATH_TYPE_NONE && item.element === undefined && item.route === undefined) {
    return {
      path: undefined,
      pathType: PATH_TYPE_NONE,
    };
  }
}

/**
 * Recursive function.
 * Insert metadata containing the navigation path and its type to each item.
 **/
function insertMetadataToItems(items, parent) {
  items.forEach(item => {
    item.meta = getItemMetadata(item, parent);

    if (item.hasOwnProperty('children')) {
      item.children = insertMetadataToItems(item.children, item);
    }
  });

  return items;
}

/**
 * Recursive function.
 * One call generates one level of the tree.
 */
function generateLevel(createElement, items, level, defaultOpenLevel) {
  const children = [];

  items.forEach(item => {
    const navItem = getNavItem(createElement, item);

    if (item.hasOwnProperty('children')) {
      children.push(
        createElement(NavigationList, {
          props: {
            level,
            defaultOpenLevel,
          },
        }, [
          navItem,
          ...generateLevel(createElement,
                           item.children,
                           level + 1,
                           defaultOpenLevel),
        ])
      );
    } else {
      children.push(createElement('li', [
        navItem,
      ]));
    }
  });

  return children;
}

export default {
  removeElementFromPath,
  getItemMetadata,
  insertMetadataToItems,
  generateLevel,
};
